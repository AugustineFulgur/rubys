#----------------------------------------------
#des算法的类 #实在是看不懂Ruby为什么要给模块设置私有 
#----------------------------------------------
class DES
#----------------------------------------------
#全局变量范围
#----------------------------------------------

    $mode #运算模式
    $cipher="" #密钥
    $ncalculate_text="" #用户输入的raw data
    $block=[] #输入的数据组织成64位块的形式
    $k=Array.new(16) {Array.new 48} #循环密钥
    $calculate_text="" #结果
    $len=0 #块的数量
    $eBox=[32, 1, 2, 3, 4, 5,
            4, 5, 6, 7, 8, 9,
            8, 9,10,11,12,13,
           12,13,14,15,16,17,
           16,17,18,19,20,21,
           20,21,22,23,24,25,
           24,25,26,27,28,29,
           28,29,30,31,32, 1] #E盒 6*8
    $sBox=Array.new(8) {Array.new(4) {Array.new 16}} #S盒 8*4*16 它的置换算法很特别 #为了我的手，这只是个表面上的三维数组
    $sBox=[ 14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7,#des算法s盒
            0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8,
            4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0,
            15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13,
            15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10,
            3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5,
            0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15,
            13,8,10,1,3,15,4,2,11,6,7,12,10,5,14,9,
            10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8,
            13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1,
            13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7,
            1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12,
            7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15,
            13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9,
            10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4,
            3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14,
            2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9,
            14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6,
            4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14,
            11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3,
            12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11,
            10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8,
            9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6,
            4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13,
            4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1,
            13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6,
            1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2,
            6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12,
            13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7,
            1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2,
            7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8,
            2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11]
    
    $pBox=[16, 7,20,21,29,12,28,17,
            1,15,23,26, 5,18,31,10,
            2, 8,24,14,32,27, 3, 9,
            19,13,30, 6,22,11, 4,25] #P盒 4*8 32位
    $ip=[ 58,50,42,34,26,18,10,2,
        60,52,44,36,28,20,12,4,
        62,54,46,38,30,22,14,6,
        64,56,48,40,32,24,16,8,
        57,49,41,33,25,17,9,1,
        59,51,43,35,27,19,11,3,
        61,53,45,37,29,21,13,5,
        63,55,47,39,31,23,15,7 ] #ip置换表 8*8
    $ipr=[40, 8,48,16,56,24,64,32,
        39, 7,47,15,55,23,63,31,
        38, 6,46,14,54,22,62,30,
        37, 5,45,13,53,21,61,29,
        36, 4,44,12,52,20,60,28,
        35, 3,43,11,51,19,59,27,
        34, 2,42,10,50,18,58,26,
        33, 1,41, 9,49,17,57,25 ] #逆转ip置换表 8*8
    $pc1=[57,49,41,33,25,17,9,
        1,58,50,42,34,26,18,
        10,2,59,51,43,35,27,
        19,11,3,60,52,44,36,
        63,55,47,39,31,23,15,
        7,62,54,46,38,30,22,
        14,6,61,53,45,37,29,
        21,13,5,28,20,12,4] #pc1置换表 8*7
    $move=[1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1] #移位表
    $pc2=[14,17,11,24,1,5,
        3,28,15,6,21,10,
        23,19,12,4,26,8,
        16,7,27,20,13,2,
        41,52,31,37,47,55,
        30,40,51,45,33,48,
        44,49,39,56,34,53,
        46,42,50,36,29,32 ] #pc2置换表 8*6

#-----------------------------------------------
#方法范围
#-----------------------------------------------

    def toBinary(str) #将字符串转换成n*八位二进制字符串
        # str :输入的字符串
        re=""
        str.each_char do |i|
            x=i.ord.to_s(2) #转换成二进制字符串
            (1..8-x.length).each do
                re+='0' #补足0
            end
            re+=x #加上字符串，现在它的长度为8的倍数
        end
        return re
    end

    def fromBinary(code) #将二进制以8位为一组转换成字符串
        re=""
        (0...code.length/8).each do |m|
            re+=code[m*8+0...m*8+8].to_i(2).chr #ascii转字母
        end
        return re
    end 

    def substitute(arr,rect) #算法中所有压缩/转置操作
        # arr :待压缩的串
        # rect:转置/压缩的矩阵(其实就是个数组)
        re=""
        rect.each do |m|
            re+=arr[m-1]
        end
        return re
    end

    def toCipher(cipher) #将用户输入的密码转换为循环密钥
        # cipher :用户输入的密码
        if cipher.length>64
            cipher=cipher[0...64] #截取64位
        elsif cipher.length<64
            (0...64-cipher.length).each do
                cipher+="0"
            end
        end #密码规整为64位
        re=pc1_sub cipher #pc1压缩 压缩后为56位
        c0=re[0...28]
        d0=re[28...56] #分割出c0、d0（各28位）
        c=Array.new 17 
        d=Array.new 17 #分割后的迭代密钥
        c[0]=c0
        d[0]=d0
        (1..16).each do |m|
            n=$move[m-1] #对于第m轮密钥，其相比于上一轮要左移的位数n
            _x=c[m-1][0...n] #切割下来的数组
            c[m]=c[m-1][n...28]+_x #这是什么，这是左移
            _y=d[m-1][0...n]
            d[m]=d[m-1][n...28]+_y
        end #对cd左右移16轮，得到16轮密钥 #记住是十六轮，也就是c0d0不算的
        sk=Array.new(16)
        (1..16).each do |m|
            sk[m-1]=c[m]+d[m] #合并两个迭代过的部分
        end
        x=Array.new(16) {Array.new 48} #我随意取，也请读者将就看看
        (0...16).each do |m|
            (0...48).each do |n|
                x[m][n]=sk[m][$pc2[n]-1] 
            end 
        end#pc2压缩 压缩后为48位
        $k=x
    end

    M,X,Y=16*4,16,1 #在模仿亲爱的三维数组
    def SSubstitute(arr) #S盒置换
        # arr :某个xor运算过后的Rn
        re=""
        (0...arr.length/6).each do |m|
            x=(arr[m*6+0]+arr[m*6+5]).to_i 2 #取出第一位和第六位合成十进制
            y=arr[m*6+1..m*6+4].to_i 2
            _re=$sBox[m*M+x*X+y*Y].to_s 2
            (0...4-_re.length).each do
                re+='0'
            end #规范位数
            re+=_re  
        end
        return re
    end
        
    def getBinary64 #将用户的输入完整的转换为n个64位块
        bina=$ncalculate_text #输入转换为二进制串
        len=(bina.length/64).to_i  #取整
        oro_len=bina.length
        re64=Array.new(len) #这是返回的64位数组
        (0..len).each do |m|
            re64[m]=bina[m*64...m*64+64]
        end
        (oro_len-len*64...64).each do
            re64[len]+="0" 
        end #填充到64的倍数
        $block=re64
        if oro_len%64 != 0 then len+=1 end #获取真正的规范后的长度，要考虑刚好整除的情况
        $len64=len
    end
        
    def code #整个运算过程
        # 根据传入的块决定是加密（$k）还是解密（倒转$k）
        re=""
        getBinary64
        (0...$len64).each do |m| #遍历所有输入的64位块
            ipmain=ip_sub $block[m] #对第n个块进行IP置换
            ipL=ipmain[0...32]
            ipR=ipmain[32...64] #切片 
            (0...16).each do |n| #16轮运算，也就是f
                ipR_e=e_sub ipR #Rn经过E盒扩展成48位 
                ipR_xor=DESxor(ipR_e,$k[yield n]) #扩展后的右半部分与Kn进行异或（解密时是K15-n） 
                ipR_s=SSubstitute ipR_xor #S盒置换 压缩到32位
                ipR_p=p_sub ipR_s #P盒置换
                ipR_p_xor=DESxor(ipR_p,ipL) #置换回32位后后右边与左边异或
                ipL=ipR
                ipR=ipR_p_xor #交换左右部分
            end
            ipR16=ipL
            ipL16=ipR #最后的交换
            _cipher=ipL16+ipR16 #与最后密文差一个ip-1的密文
            re+=ipr_sub _cipher #ip-1置换
        end
        return re #返回所有密文的二进制
    end

#----------------------------------------------
#二阶引用（也就是比较简单的派生方法）
#----------------------------------------------

    def ip_sub(arr) #ip转置
        # arr :被转置的64位数组
        return substitute(arr,$ip)
    end

    def ipr_sub(arr) #ip-1转置
        # arr :被转置的64位数组
        return substitute(arr,$ipr)
    end

    def e_sub(arr) #E盒替换
        # arr :被替换的Rn
        return substitute(arr,$eBox)
    end

    def pc1_sub(arr) #pc1置换
        # arr :被置换的初始key
        return substitute(arr,$pc1)
    end

    def DESxor(arr1,arr2) #两个数组间的异或
        # arr1、arr2:两个异或数组输入
        re=""
        (0...arr1.length).each do |m|
            re+=(arr1[m].to_i^arr2[m].to_i).to_s
        end
        return re
    end

    def p_sub(arr) #P盒置换
        # arr :被置换的Rn
        return substitute(arr,$pBox)
    end
    
    def ui
        puts "请输入你的密钥："
        toCipher gets.chomp #密钥的输入 #顺便转换为16循环二进制串了
        choc="1"
        until choc=='y'
            puts "请输入待加密/解密的数据："
            $ncalculate_text=gets.chomp #数据的输入
            getBinary64 #$ncalculate_text转换到$block
            puts "需要加密还是解密呢？(t/f)"
            case gets[0]
            when "t"
                puts code {|m| m}
            when "f"
                puts code {|m| 15-m}
            end
            puts "是否跳出？（y/n）"
            choc=gets[0]
        end
            
    end

end